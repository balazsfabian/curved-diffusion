import itertools
from pathlib import Path
import numpy as np
import sys
import argparse

import MDAnalysis as mda
from MDAnalysis.analysis.leaflet import LeafletFinder

from geodesic import ExactGeodesicMixin

import pyvista as pv

from sklearn.neighbors import NearestNeighbors

from tqdm import tqdm

import uuid

def digitize2d(A,xbins,ybins):
    """ Digitize a set of points on the 2D plane.

        This function finds the closest grid point
        index, and thus it is based on a shifted copy
        of the intervals!

        Example:
        centers : [0,1,2,3,4,5]
        bins    : [0, 0.5, 1.5, 2.5, 3.5, 4.5, 5]

        points  : -0.1 --> -1
                   0.1 --> 0
                   0.7 --> 1
                   ...
                   4.9 --> 5
                   5.1 --> 6
    """
    xb = np.hstack((xbins[0], (xbins[1:] + xbins[:-1]) * 0.5, xbins[-1]))
    yb = np.hstack((ybins[0], (ybins[1:] + ybins[:-1]) * 0.5, ybins[-1]))

    digi = np.empty(A.shape)
    digi[:,0] = np.digitize(A[:,0], xb) - 1
    digi[:,1] = np.digitize(A[:,1], yb) - 1

    return digi.astype(int)


def log_samples(start,end,num=50):
    """ start: starting point in linspace (cast to int)
        end: endpoint in linspace (cast to int)

        Casting the samples to 'int' reduces their number,
        as 1., 1.2, ... all map to 1. This is solved by
        increasing the 'apparent' num until the output has
        the desired dimensions.

        NOTE: num cannot be larger than the max number of
        integers in the range [start, end].
    """

    start = int(start)
    end = int(end)

    if start < 1 or end < 1:
        raise ValueError

    nmax = end - start + 1
    if num >= nmax:
        return np.linspace(start,end,num=nmax,dtype=int)

    s = np.log10(start)
    e = np.log10(end)
    n = num
    while True:
        out = np.unique(np.logspace(s,e, num=n,dtype=int))
        if len(out) == num:
            return out
        n += 1


class CustomFormatter(argparse.ArgumentDefaultsHelpFormatter, argparse.RawTextHelpFormatter):
    pass


desc = """Map particle positions to mesh, based on lagtime displacements.

The program takes a mesh generated by \'01-generate-mesh.py\', and discretizes
the positions so that the particle and its lagtime-shifted version both fall on
the mesh, along with their displacement vector.
"""

parser = argparse.ArgumentParser(description=desc, formatter_class=CustomFormatter)
parser.add_argument('mesh')
parser.add_argument('--logmin'  , default=1  , type=int  , help="Beginning of log-spaced lagtimes (# of frames)")
parser.add_argument('--logmax'  , default=500, type=int  , help="End of log-spaced lagtimes (# of frames)")
parser.add_argument('--logstep' , default=50 , type=int  , help="Stride of log-spaced lagtimes (# of frames)")
parser.add_argument('--trestart', default=1  , type=int  , help="Time between restarting points (# of frames)")
parser.add_argument('--maxd'    , default=20 , type=float, help="Max. allowed distance between the continous and discrete positions (angstrom)")

args = parser.parse_args()


# ##########################################
# #                                        #
# #             MAPPING TO MESH            #
# #                                        #
# ##########################################
# Load the configuration
mesh = pv.read(args.mesh)

topology = mesh.field_arrays['topology'][0]
trajectory = mesh.field_arrays['trajectory'][0]
select = mesh.field_arrays['select'][0]
leaflet = mesh.field_arrays['leaflet'][0]
lx = mesh.field_arrays['lx'][0]
ly = mesh.field_arrays['ly'][0]


u = mda.Universe(topology)
lf = LeafletFinder(u, select, pbc=True)

universe = mda.Universe(topology, trajectory)

if leaflet != 'both':
    if leaflet == "upper":
        indices = lf.groups(0).indices
    if leaflet == "lower":
        indices = lf.groups(1).indices
    selection = universe.atoms[indices]
else:
    selection = universe.select_atoms(args.lg)

print ()
print (f"* Mapping onto mesh {sys.argv[1]}")
print (f"   topology: {topology}")
print (f"   trajectory: {trajectory}")
print (f"   leaflet: \'{leaflet}\' based on group {select}")
print (f"   Selected {selection.__repr__()}")

fname = f"indices-{uuid.uuid4()}.dat"
print (f"   Saving to binary {fname}")

mesh.field_arrays['indexfile'] = (fname,)
p = Path(fname)
p.unlink(missing_ok=True)

lagtimes = log_samples(args.logmin,args.logmax,args.logstep)
print (f"   Log-spaced samples from {lagtimes[0]} to {lagtimes[-1]} -- {len(lagtimes)} steps")
pts = mesh.points
neigh = NearestNeighbors(n_neighbors=1,n_jobs=-1)
neigh.fit(pts)

largest_difference = 0
with open(p, "ab") as f:

    for i in tqdm(range(0,universe.trajectory.n_frames,args.trestart)):
        # Calling the trajectory updates the positions
        universe.trajectory[i]

        # Real CoM positions of the particles @lagtime=0
        Acont = np.array([res.atoms.center_of_mass() for res in selection.residues])
    
        # Loop over all lagtimes
        for dt in lagtimes: 
            j = dt +i
            if j >= universe.trajectory.n_frames:
                break

            universe.trajectory[j]
            Bcont = np.array([res.atoms.center_of_mass() for res in selection.residues])

            M = np.minimum(Acont,Bcont)
            shift = np.floor_divide(M,[lx,ly,np.inf])
            shift[:,0] *=lx
            shift[:,1] *=ly
            shift[:,2] = 0
            As = Acont - shift
            Bs = Bcont - shift

            dA, ndx_A = neigh.kneighbors(As)
            dB, ndx_B = neigh.kneighbors(Bs)
            ndx_A = ndx_A.flatten()
            ndx_B = ndx_B.flatten()

            # TOO LARGE DEVIATION BETWEEN SURFACE AND MOLECULE
            current_max_d = max(dA.max(),dB.max())
            if current_max_d > largest_difference:
                largest_difference = current_max_d

            if current_max_d > args.maxd:
                raise ValueError("Too large differences between the mesh and the trajectory!")

            indices = np.minimum(ndx_A,ndx_B), np.maximum(ndx_A,ndx_B), np.zeros(ndx_A.shape)+j-i
            indices = np.array(indices,dtype=np.int32).T
            indices.tofile(f)


print (f"* Largest distance between mesh and particle: {largest_difference} A")
print ()
print ("*Â Updating the mesh metadata")
mesh.field_arrays['lagtimes'] = lagtimes
mesh.save(args.mesh)
